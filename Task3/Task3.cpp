#include <iostream>  // Подключение библиотеки для работы с вводом-выводом
#include <vector>    // Подключение библиотеки для работы с контейнером vector

using namespace std;  // Использование стандартного пространства имен

// Функция для построения матрицы смежности из списка рёбер
vector<vector<int>> buildAdjacencyMatrix(int n, vector<pair<int, int>>& edges) {
    vector<vector<int>> adjMatrix(n, vector<int>(n, 0));  // Инициализация матрицы смежности нулями размером n x n

    // Заполнение матрицы смежности на основе списка рёбер
    for (pair<int, int>& edge : edges) {  // Проход по всем рёбрам
        adjMatrix[edge.first][edge.second] = 1;  // Установка связи между вершинами в одном направлении
        adjMatrix[edge.second][edge.first] = 1;  // Установка связи между вершинами в другом направлении, так как граф неориентированный
    }
    return adjMatrix;  // Возврат построенной матрицы смежности
}

// Функция для проверки, является ли множество вершин независимым
bool isIndependentSet(const vector<vector<int>>& adjMatrix, const vector<int>& subset) {
    int n = adjMatrix.size();  // Определение размера графа

    // Проверка, нет ли смежных вершин в подмножестве
    for (int i = 0; i < n; ++i) {  // Проход по всем вершинам
        if (subset[i]) {  // Если вершина включена в подмножество
            for (int j = i + 1; j < n; ++j) {  // Проверка остальных вершин после текущей
                if (subset[j] && adjMatrix[i][j] == 1) {  // Если вершина j также включена в подмножество и смежна с вершиной i
                    return false;  // Подмножество не является независимым
                }
            }
        }
    }

    return true;  // Если нет смежных вершин в подмножестве, оно является независимым
}

// Функция для поиска максимального независимого множества
vector<int> findMaximumIndependentSet(vector<vector<int>>& adjMatrix) {
    int n = adjMatrix.size();  // Определение размера графа
    vector<int> bestSet(n, 0);  // Инициализация лучшего найденного независимого множества нулями
    int maxSize = 0;  // Начальный максимальный размер независимого множества - ноль

    // Перебор всех возможных подмножеств вершин
    for (int i = 1; i < (1 << n); ++i) {  // Перебор всех возможных комбинаций вершин
        vector<int> subset(n, 0);  // Инициализация подмножества
        int count = 0;  // Счетчик количества вершин в подмножестве

        for (int j = 0; j < n; ++j) {  // Проход по всем вершинам
            if (i & (1 << j)) {  // Проверка, включена ли вершина j в текущую комбинацию
                subset[j] = 1;  // Включение вершины j в подмножество
                count++;  // Увеличение счетчика количества вершин
            }
        }

        if (isIndependentSet(adjMatrix, subset)) {  // Проверка, является ли текущее подмножество независимым
            if (count > maxSize) {  // Если текущее независимое множество больше найденного ранее
                maxSize = count;  // Обновление максимального размера
                bestSet = subset;  // Обновление лучшего независимого множества
            }
        }
    }

    // Создание списка вершин на основе лучшего найденного подмножества
    vector<int> result;  // Инициализация результата
    for (int i = 0; i < n; ++i) {  // Проход по всем вершинам
        if (bestSet[i]) {  // Если вершина включена в лучшее независимое множество
            result.push_back(i);  // Добавление вершины в результат
        }
    }

    return result;  // Возврат результата - максимального независимого множества
}

// Функция для ввода готовой матрицы смежности
vector<vector<int>> inputAdjacencyMatrix(int n) {
    vector<vector<int>> adjMatrix(n, vector<int>(n));  // Инициализация матрицы смежности размером n x n

    cout << "Введите матрицу смежности (" << n << " x " << n << "):\n";  // Вывод приглашения для ввода матрицы

    for (int i = 0; i < n; ++i) {  // Проход по строкам матрицы
        for (int j = 0; j < n; ++j) {  // Проход по столбцам матрицы
            cin >> adjMatrix[i][j];  // Ввод значения элемента матрицы
        }
    }
    return adjMatrix;  // Возврат введенной матрицы смежности
}

int main() {
    // Ввод данных
    setlocale(0, "");  // Установка локали для корректного отображения русского текста
    int n, m, choice;  // Переменные для количества вершин, рёбер и выбора способа ввода

    cout << "Выберите способ ввода графа:\n";  // Вывод приглашения для выбора способа ввода
    cout << "1. Ввести список рёбер\n";  // Вывод первого варианта ввода
    cout << "2. Ввести матрицу смежности\n";  // Вывод второго варианта ввода
    cin >> choice;  // Ввод выбора

    vector<vector<int>> adjMatrix;  // Инициализация матрицы смежности

    // Обработка выбора способа ввода
    if (choice == 1) {  // Если выбран ввод списка рёбер
        cout << "Введите количество вершин и рёбер: ";  // Вывод приглашения для ввода количества вершин и рёбер
        cin >> n >> m;  // Ввод количества вершин и рёбер
        vector<pair<int, int>> edges(m);  // Инициализация списка рёбер
        cout << "Введите рёбра (пары вершин):\n";  // Вывод приглашения для ввода рёбер
        for (int i = 0; i < m; ++i) {  // Проход по всем рёбрам
            cin >> edges[i].first >> edges[i].second;  // Ввод рёбер
        }
        adjMatrix = buildAdjacencyMatrix(n, edges);  // Построение матрицы смежности
    }
    else if (choice == 2) {  // Если выбран ввод матрицы смежности
        cout << "Введите количество вершин: ";  // Вывод приглашения для ввода количества вершин
        cin >> n;  // Ввод количества вершин
        adjMatrix = inputAdjacencyMatrix(n);  // Ввод матрицы смежности
    }
    else {  // Если введён некорректный выбор
        cout << "Некорректный выбор.\n";  // Вывод сообщения об ошибке
        return 1;  // Завершение программы с кодом ошибки
    }

    // Построение матрицы смежности
    cout << "\nМатрица смежности: \n";  // Вывод заголовка матрицы смежности
    for (int i = 0; i < adjMatrix.size(); i++) {  // Проход по строкам матрицы
        for (int j = 0; j < adjMatrix[i].size(); j++) {  // Проход по столбцам матрицы
            cout << adjMatrix[i][j] << "\t";  // Вывод элемента матрицы
        }
        cout << endl;  // Переход на новую строку
    }

    // Поиск максимального независимого множества
    vector<int> maxIndependentSet = findMaximumIndependentSet(adjMatrix);  // Нахождение максимального независимого множества

    // Вывод результата
    cout << "Максимальное независимое множество вершин графа:\n";  // Вывод заголовка результата
    for (int vertex : maxIndependentSet) {  // Проход по вершинам максимального независимого множества
        cout << vertex << " ";  // Вывод вершины
    }
    cout << "\nЧисло внешней устойчивости графа: " << maxIndependentSet.size() << endl;  // Вывод размера максимального независимого множества

    return 0;  // Завершение программы
}
/********************************************************************/
/*5 7
0 1
1 2
0 3
3 4
3 1
4 1
4 2
*/